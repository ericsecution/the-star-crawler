/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (() => {

eval("// Working with Canvas to create a cool \"star crawler\" that follows the cursor around\n// and...ok, I think that I finally got it to work! Lol, stardate: Mon July 3rd, 2023\n\nwindow.requestAnimFrame = function () {\n\treturn (\n\t\twindow.requestAnimationFrame ||\n\t\twindow.webkitRequestAnimationFrame ||\n\t\twindow.mozRequestAnimationFrame ||\n\t\twindow.oRequestAnimationFrame ||\n\t\twindow.msRequestAnimationFrame ||\n\t\tfunction (callback) {\n\t\t\twindow.setTimeout(callback, 1000 / 60);\n\t\t}\n\t);\n};\n\n/*  setup the canvas to create a 2D rendering of the canvas ('c'), so I can draw onto it, \n        and set its boundaries equal to the width and height of the user's browser window \n        (using 'w', and 'h')\n    */\nfunction init(elemid) {\n\tlet canvas = document.getElementById(elemid);\n\tlet c = canvas.getContext('2d');\n\tcanvas.width = window.innerWidth;\n\tcanvas.height = window.innerHeight;\n\tlet w = canvas.width;\n\tlet h = canvas.height;\n\tc.fillStyle = 'rgba(30,30,30,1)';\n\tc.fillRect(0, 0, w, h);\n\treturn { c: c, canvas: canvas };\n}\n\nwindow.onload = function () {\n\t/* added in 'canvasData' to call 'init()' once, and will use its returned values\n    // before, I had it setup with:\n        let c = init(\"canvas\").c,\n        canvas = init(\"canvas\").canvas\n    // which was duplicating the resizing and unneccessarily overriding width and height\n    */\n\tlet canvasData = init('canvas');\n\tlet c = canvasData.c,\n\t\tcanvas = canvasData.canvas,\n\t\tw = canvas.width,\n\t\th = canvas.height,\n\t\t// going to be tracking user's 'mouse' using x & y coordinates (i.e. current position)\n\t\tmouse = { x: false, y: false },\n\t\t// I'll use the 'last_mouse' object to track user's mouse's previous position\n\t\tlast_mouse = {};\n\n\t// create a helper function to calc Euclidean distance using Math.sqrt & Math.pow\n\tfunction dist(p1x, p1y, p2x, p2y) {\n\t\treturn Math.sqrt(Math.pow(p2x - p1x, 2) + Math.pow(p2y - p1y, 2));\n\t}\n\n\tclass segment {\n\t\t// when a new instance of the segment class is created, the constructor's called\n\t\t// l = length of the segment; and a = angle of the segment\n\t\tconstructor(parent, l, a, first) {\n\t\t\tthis.first = first;\n\t\t\t// if first is true, this segment's the first segment, and pos is set to parent\n\t\t\tif (first) {\n\t\t\t\tthis.pos = {\n\t\t\t\t\tx: parent.x,\n\t\t\t\t\ty: parent.y,\n\t\t\t\t};\n\t\t\t\t// otherwise, if first is false, pos is set to nextPos\n\t\t\t} else {\n\t\t\t\tthis.pos = {\n\t\t\t\t\tx: parent.nextPos.x,\n\t\t\t\t\ty: parent.nextPos.y,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// nextPos is calculated using trigonometric functions to determine x,y coordinates\n\t\t\t// it uses current position (pos), length (l) and angle (ang)\n\t\t\tthis.l = l;\n\t\t\tthis.ang = a;\n\t\t\tthis.nextPos = {\n\t\t\t\tx: this.pos.x + this.l * Math.cos(this.ang),\n\t\t\t\ty: this.pos.y + this.l * Math.sin(this.ang),\n\t\t\t};\n\t\t}\n\t\t// then, I want to call the update(t) method here in the segment class\n\t\t// this will allow the Star Crawler to be repositioned, using the\n\t\t// position (pos) and angle (ang)of a segment, based on the target position\n\t\tupdate(t) {\n\t\t\t// calculate the angle the segment should move based off comparing the target (t)\n\t\t\t// to the segment's current position (this.pos), using the Math.atan2() function\n\t\t\tthis.ang = Math.atan2(t.y - this.pos.y, t.x - this.pos.x);\n\t\t\tthis.pos.x = t.x + this.l * Math.cos(this.ang - Math.PI);\n\t\t\tthis.pos.y = t.y + this.l * Math.sin(this.ang - Math.PI);\n\t\t\tthis.nextPos.x = this.pos.x + this.l * Math.cos(this.ang);\n\t\t\tthis.nextPos.y = this.pos.y + this.l * Math.sin(this.ang);\n\t\t}\n\t\t// Then I'm going to call in the fallback(t) function to update the position\n\t\t// of an object based on a target(t) within a two-dimensional coordinate system\n\t\t// the goal here is to make the x,y coordinates accessible (this.pos.x & this.pos.y)\n\t\t// and bring the object closer to the target position, creating a smoother transition\n\t\tfallback(t) {\n\t\t\tthis.pos.x = t.x;\n\t\t\tthis.pos.y = t.y;\n\t\t\tthis.nextPos.x = this.pos.x + this.l * Math.cos(this.ang);\n\t\t\tthis.nextPos.y = this.pos.y + this.l * Math.sin(this.ang);\n\t\t}\n\t\tshow() {\n\t\t\tc.lineTo(this.nextPos.x, this.nextPos.y);\n\t\t}\n\t}\n\n\tclass crawler {\n\t\tconstructor(x, y, l, n, a) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.l = l;\n\t\t\tthis.n = n; // number of segments\n\t\t\tthis.t = {};\n            this.hue = Math.floor(Math.random() * (345 - 330 + 1) + 330); // for pink\n        \tthis.rand = Math.random();\n\n\t\t\t// initialize the first segment (i.e. the lone 'this' creates the first instance\n\t\t\t// of the crawler, which is essentially its first leg), where angle = 0, to start\n\t\t\t// My for loop is used to fill out the segments array with each new segment instance\n\t\t\t// first segment is marked as such by the 'true' parameter, and new segments shown\n\t\t\t// !first by utilizing the 'false' parameter within the for loop & its push method\n\t\t\tthis.segments = [new segment(this, this.l / this.n, 0, true)];\n\t\t\tfor (let i = 1; i < this.n; i++) {\n\t\t\t\tthis.segments.push(\n\t\t\t\t\tnew segment(this.segments[i - 1], this.l / this.n, 0, false)\n\t\t\t\t);\n\t\t\t}\n\t\t} // close of constructor() for Crawler class\n\t\tmove(last_target, target) {\n\t\t\t// using Math.atan2() again to calculate the angle (in radians) for my cralwer movements\n\t\t\tthis.angle = Math.atan2(target.y - this.y, target.x - this.x);\n\n\t\t\t// calculate duration (dt) based on the Euclidean distance (dist function) of the\n\t\t\t// last target position and the current target position, then add 5 units in order\n\t\t\t// to gain a slight overlap between current position and the new target position\n\t\t\tthis.dt = dist(last_target.x, last_target.y, target.x, target.y) + 5;\n\n\t\t\t// then subtract 80% (of the duration multiplied by the cosine and sine of the angle)\n\t\t\t// and create a temp target (t) position of the x, y coordinates, for smoother movements\n\t\t\tthis.t = {\n\t\t\t\tx: target.x - 0.8 * this.dt * Math.cos(this.angle),\n\t\t\t\ty: target.y - 0.8 * this.dt * Math.sin(this.angle),\n\t\t\t};\n\n\t\t\t// recalculate the position of each segment, starting with the last (this.n -1)\n\t\t\tif (this.t.x) {\n\t\t\t\tthis.segments[this.n - 1].update(this.t);\n\t\t\t} else {\n\t\t\t\tthis.segments[this.n - 1].update(target);\n\t\t\t}\n\t\t\t// then iterate thru to the first segment starting with the next (2nd to last) one\n\t\t\tfor (let i = this.n - 2; i >= 0; i--) {\n\t\t\t\tthis.segments[i].update(this.segments[i + 1].pos);\n\t\t\t}\n\t\t\t/* Check to see if this object is close to / has reached the target position:\n            // if the distance between the object's current position and the target position\n            // are less than or equal to the sum of its (length + the distance between the \n            // last target and the current target), then the fallback() method is called\n            // to ensure a more seamless transition by aligning the object's segments with\n            // its current position.\n            */\n\t\t\tif (\n\t\t\t\tdist(this.x, this.y, target.x, target.y) <=\n\t\t\t\tthis.l + dist(last_target.x, last_target.y, target.x, target.y)\n\t\t\t) {\n\t\t\t\tthis.segments[0].fallback({ x: this.x, y: this.y });\n\t\t\t\tfor (let i = 1; i < this.n; i++) {\n\t\t\t\t\tthis.segments[i].fallback(this.segments[i - 1].nextPos);\n\t\t\t\t}\n\t\t\t}\n\t\t} // close of move()\n\t\tshow(target) {\n\t\t\tif (dist(this.x, this.y, target.x, target.y) <= this.l) {\n\t\t\t\tc.globalCompositeOperation = 'lighter';\n\t\t\t\tc.beginPath();\n\t\t\t\tc.lineTo(this.x, this.y);\n\t\t\t\tfor (let i = 0; i < this.n; i++) {\n\t\t\t\t\tthis.segments[i].show();\n\t\t\t\t}\n\t\t\t\tc.strokeStyle =\n\t\t\t\t\t'hsl(' +\n\t\t\t\t\t(this.rand * 60 + 180) +\n\t\t\t\t\t',100%,' +\n\t\t\t\t\t(this.rand * 60 + 25) +\n\t\t\t\t\t'%)';\n\t\t\t\tc.lineWidth = this.rand * 2;\n\t\t\t\tc.lineCap = 'round';\n\t\t\t\tc.lineJoin = 'round';\n\t\t\t\tc.stroke();\n\t\t\t\tc.globalCompositeOperation = 'source-over';\n\t\t\t}\n\t\t} // close of show()\n\t\tshow2(target) {\n\t\t\tc.beginPath();\n\t\t\tif (dist(this.x, this.y, target.x, target.y) <= this.l) {\n\t\t\t\tc.arc(this.x, this.y, 2 * this.rand + 1, 0, 2 * Math.PI);\n\t\t\t\tc.fillStyle = 'white';\n\t\t\t} else {\n\t\t\t\tc.arc(this.x, this.y, this.rand * 2, 0, 2 * Math.PI);\n\t\t\t\tc.fillStyle = 'darkcyan';\n\t\t\t}\n\t\t\tc.fill();\n\t\t} // close of show2()\n\t} // close of crawler class\n\n\tclass slowCrawler extends crawler {\n\t\tconstructor(x, y, l, n, a) {\n\t\t\tsuper(x, y, l, n, a);\n\t\t}\n\n\t\tmove(last_target, target) {\n\t\t\tthis.angle = Math.atan2(target.y - this.y, target.x - this.x);\n\t\t\tthis.dt = dist(last_target.x, last_target.y, target.x, target.y) + 5;\n\n\t\t\t// divide this.dt (the delta time of the slowCrawler) by 4 to slow down the movement\n\t\t\tthis.dt /= 4;\n\n\t\t\tthis.t = {\n\t\t\t\tx: target.x - 0.8 * this.dt * Math.cos(this.angle),\n\t\t\t\ty: target.y - 0.8 * this.dt * Math.sin(this.angle),\n\t\t\t};\n\n\t\t\tif (this.t.x) {\n\t\t\t\tthis.segments[this.n - 1].update(this.t);\n\t\t\t} else {\n\t\t\t\tthis.segments[this.n - 1].update(target);\n\t\t\t}\n\n\t\t\tfor (let i = this.n - 2; i >= 0; i--) {\n\t\t\t\tthis.segments[i].update(this.segments[i + 1].pos);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tdist(this.x, this.y, target.x, target.y) <=\n\t\t\t\tthis.l + dist(last_target.x, last_target.y, target.x, target.y)\n\t\t\t) {\n\t\t\t\tthis.segments[0].fallback({ x: this.x, y: this.y });\n\t\t\t\tfor (let i = 1; i < this.n; i++) {\n\t\t\t\t\tthis.segments[i].fallback(this.segments[i - 1].nextPos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlet maxl = 300,\n\t\tminl = 50,\n\t\tn = 33,\n\t\tnumt = 500,\n\t\ttent = [],\n\t\tclicked = false,\n\t\ttarget = { x: 0, y: 0 },\n\t\tlast_target = {},\n\t\tt = 0,\n\t\tq = 10;\n\n\tfor (let i = 0; i < numt; i++) {\n\t\tif (Math.random() > 0.5) {\n\t\t\ttent.push(\n\t\t\t\tnew crawler(\n\t\t\t\t\tMath.random() * w,\n\t\t\t\t\tMath.random() * h,\n\t\t\t\t\tMath.random() * (maxl - minl) + minl,\n\t\t\t\t\tn,\n\t\t\t\t\tMath.random() * 2 * Math.PI\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\ttent.push(\n\t\t\t\tnew slowCrawler(\n\t\t\t\t\tMath.random() * w,\n\t\t\t\t\tMath.random() * h,\n\t\t\t\t\tMath.random() * (maxl - minl) + minl,\n\t\t\t\t\tn,\n\t\t\t\t\tMath.random() * 2 * Math.PI\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction draw() {\n\t\tif (mouse.x) {\n\t\t\ttarget.errx = mouse.x - target.x;\n\t\t\ttarget.erry = mouse.y - target.y;\n\t\t} else {\n\t\t\ttarget.errx =\n\t\t\t\tw / 2 +\n\t\t\t\t((h / 2 - q) *\n\t\t\t\t\tMath.sqrt(2) *\n\t\t\t\t\tMath.cos((t / 1000) * 2 * Math.PI) *\n\t\t\t\t\tMath.sin((t / 1000) * 2 * Math.PI)) /\n\t\t\t\t\t(Math.pow(Math.sin((t / 1000) * 2 * Math.PI), 2) + 1) -\n\t\t\t\ttarget.x;\n\t\t\ttarget.erry =\n\t\t\t\th / 2 +\n\t\t\t\t((h / 2 - q) *\n\t\t\t\t\tMath.sqrt(2) *\n\t\t\t\t\tMath.cos((t / 1000) * 2 * Math.PI) *\n\t\t\t\t\tMath.sin((t / 1000) * 2 * Math.PI)) /\n\t\t\t\t\t(Math.pow(Math.sin((t / 1000) * 2 * Math.PI), 2) + 1) -\n\t\t\t\ttarget.y;\n\t\t}\n\n\t\ttarget.x += target.errx / 10;\n\t\ttarget.y += target.erry / 10;\n\n\t\tt += 0.01;\n\n\t\tc.beginPath();\n\t\tc.arc(\n\t\t\ttarget.x,\n\t\t\ttarget.y,\n\t\t\tdist(last_target.x, last_target.y, target.x, target.y) + 5,\n\t\t\t0,\n\t\t\t2 * Math.PI\n\t\t);\n\t\tthis.ctx.fillStyle = 'hsla(' + this.hue + ', 100%, 50%, 0.1)';\n\n\t\tc.fill();\n\n        for (let i = 0; i < numt; i++) {\n            tent[i].move(last_target, target);\n            // check if the crawler is an instance of slowCrawler\n            if (tent[i] instanceof slowCrawler) {\n                tent[i].show2(target); // use a different show method for slowCrawlers\n            } else {\n                tent[i].show(target); // use normal show method for regular crawlers\n            }\n        }\n\n        last_target.x = target.x;\n        last_target.y = target.y;\n    } // end of draw() function\n\n    // continuously call the draw() function\n    function loop() {\n        c.fillStyle = 'rgba(30,30,30,1)';\n        c.fillRect(0, 0, w, h);\n        draw();\n        window.requestAnimFrame(loop);\n    }\n\n    // event listener for when the user clicks\n    canvas.addEventListener('mousedown', function (e) {\n        clicked = true;\n        last_mouse.x = e.pageX - this.offsetLeft;\n        last_mouse.y = e.pageY - this.offsetTop;\n    });\n\n    // event listener for when the user releases the mouse click\n    canvas.addEventListener('mouseup', function () {\n        clicked = false;\n        last_mouse.x = false;\n        last_mouse.y = false;\n    });\n\n    // event listener for when the user moves the mouse\n    canvas.addEventListener('mousemove', function (e) {\n        if (clicked) {\n            mouse.x = e.pageX - this.offsetLeft;\n            mouse.y = e.pageY - this.offsetTop;\n        }\n    });\n\n    loop(); // call the loop() function to start the animation\n}; // end of window.onload function\n\n\n//# sourceURL=webpack://the-star-crawler/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.js"]();
/******/ 	
/******/ })()
;